<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mechanical Flip Counter</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        /* Custom 3D styles not covered by Tailwind utilities */
        .perspective-container {
            perspective: 1000px;
        }
        
        .drum-container {
            transform-style: preserve-3d;
            /* Will be animated via JS */
        }
        
        .drum-face {
            backface-visibility: hidden;
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #1a1a1a;
            color: #f0f0f0;
        }

        /* Gradient overlay for cylindrical look */
        .glass-overlay {
            background: linear-gradient(to bottom, 
                rgba(0,0,0,1) 0%, 
                rgba(0,0,0,0.4) 15%, 
                rgba(255,255,255,0.05) 45%, 
                rgba(255,255,255,0.05) 55%, 
                rgba(0,0,0,0.4) 85%, 
                rgba(0,0,0,1) 100%);
            pointer-events: none;
            z-index: 10;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
        }
        
        /* Font styling for the digits */
        .digit-font {
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            font-size: 3.5rem;
            line-height: 1;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        /* Specific dimensions for the drum calculation
           Height: 80px
           Faces: 10
           Angle per face: 36deg
           Radius = (80 / 2) / tan(18deg) ≈ 40 / 0.3249 ≈ 123px
        */
        .drum-height {
            height: 80px;
        }
    </style>
</head>
<body class="bg-neutral-900 text-white min-h-screen flex flex-col items-center justify-center font-sans">

    <div class="mb-12 text-center">
        <h1 class="text-3xl font-bold tracking-widest text-neutral-400 mb-2 uppercase">Mechanical Counter</h1>
        <p class="text-neutral-500 text-sm">Rotating Drum Counter</p>
    </div>

    <!-- Main Counter Display -->
    <div class="relative bg-black p-4 rounded-xl border-4 border-neutral-700 shadow-2xl flex items-center justify-center gap-1 sm:gap-2 lg:gap-3">
        
        <!-- Glass/Reflection Overlay -->
        <div class="absolute inset-0 z-20 rounded-lg pointer-events-none shadow-[inset_0_0_20px_rgba(0,0,0,1)] border border-neutral-600 opacity-50"></div>

        <!-- Drums Container will be injected here -->
        <div id="counter-stage" class="flex gap-1 sm:gap-2">
            <!-- Digits generated by JS -->
        </div>

    </div>

    <!-- Controls -->
    <div class="mt-12 flex gap-6">
        <button id="btn-dec" class="group relative px-6 py-3 bg-red-900 hover:bg-red-700 rounded-full shadow-lg border-b-4 border-red-950 active:border-b-0 active:translate-y-1 transition-all">
            <span class="text-xl font-bold text-red-100">- Decrement</span>
        </button>
        
        <button id="btn-inc" class="group relative px-6 py-3 bg-green-900 hover:bg-green-700 rounded-full shadow-lg border-b-4 border-green-950 active:border-b-0 active:translate-y-1 transition-all">
            <span class="text-xl font-bold text-green-100">+ Increment</span>
        </button>
    </div>
    
    <div class="mt-8 flex gap-4">
        <button id="btn-auto" class="px-4 py-2 bg-neutral-700 hover:bg-neutral-600 rounded text-sm font-mono border-b-2 border-neutral-900 active:border-b-0 active:translate-y-[2px]">
            Auto Run
        </button>
        <button id="btn-reset" class="px-4 py-2 bg-neutral-700 hover:bg-neutral-600 rounded text-sm font-mono border-b-2 border-neutral-900 active:border-b-0 active:translate-y-[2px]">
            Reset
        </button>
    </div>

    <script>
        // Sound Controller
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playClickSound() {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            osc.type = 'triangle';
            // Randomize pitch slightly for realism
            osc.frequency.setValueAtTime(100 + Math.random() * 50, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.05);
            
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
            
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            osc.start();
            osc.stop(audioCtx.currentTime + 0.05);
        }

        // Configuration
        const DRUM_COUNT = 6;
        const FACE_HEIGHT = 80; // px
        const FACE_WIDTH = 50;  // px
        const FACES = 10;
        const ANGLE_PER_FACE = 360 / FACES;
        // Radius calculation: r = (h/2) / tan(18deg)
        const RADIUS = Math.round((FACE_HEIGHT / 2) / Math.tan(Math.PI / FACES)); 

        let count = 0;
        let drumRotations = new Array(DRUM_COUNT).fill(0); // Stores the current rotation angle for each drum
        let autoInterval = null;

        const stage = document.getElementById('counter-stage');

        // Initialize Drums
        function initDrums() {
            stage.innerHTML = '';
            
            for (let i = 0; i < DRUM_COUNT; i++) {
                // Wrapper for perspective
                const wrapper = document.createElement('div');
                wrapper.className = `perspective-container overflow-hidden relative bg-neutral-900 rounded border-y border-neutral-800 shadow-inner`;
                wrapper.style.width = `${FACE_WIDTH}px`;
                wrapper.style.height = `${FACE_HEIGHT}px`;

                // The rotating drum
                const drum = document.createElement('div');
                drum.className = 'drum-container w-full h-full absolute top-0 left-0 transition-transform duration-700 cubic-bezier(0.25, 1, 0.5, 1)';
                drum.id = `drum-${i}`;
                
                // Create faces
                for (let j = 0; j < FACES; j++) {
                    const face = document.createElement('div');
                    face.className = 'drum-face bg-neutral-800 text-white text-4xl digit-font border-t border-b border-neutral-700/50';
                    face.textContent = j;
                    
                    // Transform face to form the cylinder
                    // Rotate X axis, then translate Z out
                    // For odometer logic (0 goes UP, 1 comes from BOTTOM), 
                    // Face 1 should be "below" Face 0.
                    // Face 0 at 0deg. Face 1 at -36deg (visually below in 3D space relative to viewer center? No, negative rotateX brings bottom towards you).
                    // Let's stick to standard: Face j at -j * 36.
                    // If Face 1 is at -36. To bring it to 0, we rotate Drum by +36.
                    // Face 0 moves to +36 (Up). Perfect.
                    face.style.transform = `rotateX(${-j * ANGLE_PER_FACE}deg) translateZ(${RADIUS}px)`;
                    
                    drum.appendChild(face);
                }

                wrapper.appendChild(drum);
                
                // Add shading overlay
                const overlay = document.createElement('div');
                overlay.className = 'glass-overlay absolute inset-0 w-full h-full';
                wrapper.appendChild(overlay);

                stage.appendChild(wrapper);
            }
            
            updateDrums(0, false); // Initial render
        }

        // Update drum positions based on the number
        function updateDrums(newCount, animate = true) {
            // Clamp count to positive integers (optional, usually odometers don't go negative well physically)
            // But we can support it or just loop. Let's stick to positive modulo max.
            const maxVal = Math.pow(10, DRUM_COUNT) - 1;
            if (newCount < 0) newCount = maxVal;
            if (newCount > maxVal) newCount = 0;
            
            count = newCount;

            // Update each drum
            let tempCount = count;
            
            for (let i = DRUM_COUNT - 1; i >= 0; i--) {
                const digit = tempCount % 10;
                tempCount = Math.floor(tempCount / 10);
                
                const drum = document.getElementById(`drum-${i}`);
                
                // Calculate target rotation
                // The face for digit D is at rotation D * 36deg.
                // However, to show D, we need to rotate the drum by -D * 36deg.
                // We also need to handle the "infinite" scroll so we don't unwind.
                
                const currentRotation = drumRotations[i];
                
                // New Logic: 
                // Face j is at -j * 36.
                // To show Digit D, we want Face D at 0.
                // Current Face D position = (-D * 36) + DrumRotation.
                // We want (-D * 36) + DrumRotation = 0 (modulo 360).
                // So DrumRotation should be D * 36.
                
                let targetAngle = digit * ANGLE_PER_FACE;
                
                // We want to move smoothly from currentRotation to targetAngle.
                // Find k such that (targetAngle + k*360) is closest to currentRotation.
                
                // However, we must respect the "Odometer Direction".
                // 0 -> 1: Drum rotates +36. (Increment = Positive Delta)
                // 1 -> 2: Drum rotates +36.
                // 9 -> 0: Drum rotates +36.
                
                // If we use shortest path:
                // 9 (at 324) -> 0 (at 0 or 360).
                // 0 - 324 = -324. Shortest path is +36 (360 - 324). 
                // 360 is target.
                // So 324 -> 360 is +36. Correct.
                
                // 0 (at 0) -> 9 (at 324 or -36).
                // 324 - 0 = 324. Shortest path is -36.
                // -36 is target.
                // 0 -> -36 is -36. Correct (Decrement).
                
                // So Shortest Path logic still works perfectly!
                
                while (targetAngle - currentRotation > 180) targetAngle -= 360;
                while (targetAngle - currentRotation < -180) targetAngle += 360;
                
                // Force wrap consistency for 9<->0 to ensure it doesn't backflip if something is slightly off
                // But shortest path handles 9->0 as +36 and 0->9 as -36 properly.
                
                drumRotations[i] = targetAngle;
                
                if (animate) {
                    // Only play sound if this drum is actually moving
                    if (Math.abs(targetAngle - currentRotation) > 1) {
                         // Debounce sound per update frame (simplification: just play once per update call roughly, or per drum?)
                         // Per drum sounds messy. Let's play one click per updateDrums call if ANY drum moves.
                    }
                    
                    drum.style.transition = 'transform 0.6s cubic-bezier(0.15, 0.9, 0.35, 1.2)'; // Add a little bounce
                    drum.style.transform = `rotateX(${targetAngle}deg)`;
                } else {
                    drum.style.transition = 'none';
                    drum.style.transform = `rotateX(${targetAngle}deg)`;
                }
            }
            
            if (animate) playClickSound();
        }

        // Initialize
        initDrums();

        // Event Listeners
        document.getElementById('btn-inc').addEventListener('click', () => {
            updateDrums(count + 1);
        });

        document.getElementById('btn-dec').addEventListener('click', () => {
            updateDrums(count - 1);
        });

        document.getElementById('btn-reset').addEventListener('click', () => {
            updateDrums(0);
        });
        
        document.getElementById('btn-auto').addEventListener('click', (e) => {
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
                e.target.textContent = "Auto Run";
                e.target.classList.remove('bg-green-700');
                e.target.classList.add('bg-neutral-700');
            } else {
                e.target.textContent = "Stop Auto";
                e.target.classList.remove('bg-neutral-700');
                e.target.classList.add('bg-green-700');
                autoInterval = setInterval(() => {
                    updateDrums(count + 1);
                }, 200);
            }
        });

        // Keyboard support
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp' || e.key === 'ArrowRight') updateDrums(count + 1);
            if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') updateDrums(count - 1);
        });

    </script>
</body>
</html>
